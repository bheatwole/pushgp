use crate::instruction_table::InstructionTable;
use crate::{
    Bool, Code, Configuration, Context, ContextStack, EphemeralConfiguration, Exec, Float, InstructionConfiguration,
    InstructionTrait, Integer, Literal, LiteralConstructor, Name, Parser, Stack, SupportsDefinedNames, SupportsLiteralNames,
};
use fnv::FnvHashMap;
use nom::IResult;
use std::fmt::{Display, Formatter, Result};
use std::rc::Rc;

// This file contains all the bits that will need to be code generated by macros in order for this to work. For the
// default version, we simply hand-code everything and then work on the macros to make this happen.

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum BaseLiteral {
    Bool(Bool),
    Float(Float),
    Integer(Integer),
    Name(Name),
}

impl Display for BaseLiteral {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        match &self {
            BaseLiteral::Bool(v) => v.nom_fmt(f),
            BaseLiteral::Float(v) => write!(f, "{}", v),
            BaseLiteral::Integer(v) => write!(f, "{}", v),
            BaseLiteral::Name(v) => write!(f, "{}", v),
        }
    }
}

impl Literal<BaseLiteral> for BaseLiteral {
    fn parse(input: &str) -> IResult<&str, BaseLiteral> {
        if let Ok((rest, value)) = Bool::parse(input) {
            return Ok((rest, BaseLiteral::Bool(value)));
        }
        if let Ok((rest, value)) = crate::parse::parse_code_float(input) {
            return Ok((rest, BaseLiteral::Float(value)));
        }
        if let Ok((rest, value)) = crate::parse::parse_code_integer(input) {
            return Ok((rest, BaseLiteral::Integer(value)));
        }
        if let Ok((rest, value)) = crate::parse::parse_code_name(input) {
            return Ok((rest, BaseLiteral::Name(value)));
        }

        Err(nom::Err::Error(nom::error::Error::new(input, nom::error::ErrorKind::Complete)))
    }

    fn random_value<R: rand::Rng>(rng: &mut R) -> BaseLiteral {
        let index: usize = rng.gen_range(0..4);
        match index {
            0 => BaseLiteral::Bool(Bool::random_value(rng)),
            1 => BaseLiteral::Float(Float::random_value(rng)),
            2 => BaseLiteral::Integer(Integer::random_value(rng)),
            3 => BaseLiteral::Name(Name::random_value(rng)),
            _ => panic!("indicates an error in macro code")
        }
    }
}

impl crate::execute_bool::MakeBoolLiteral<BaseLiteral> for BaseLiteral {
    fn make_bool_literal(b: Bool) -> BaseLiteral {
        BaseLiteral::Bool(b)
    }
}

impl EphemeralConfiguration<BaseLiteral> for BaseLiteral {
    fn get_all_literal_types() -> Vec<String> {
        vec!["Bool".to_owned(), "Float".to_owned(), "Integer".to_owned(), "Name".to_owned()]
    }

    fn make_literal_constructor_for_type(literal_type: &str) -> LiteralConstructor<BaseLiteral> {
        match literal_type {
            "Bool" => |rng| { BaseLiteral::Bool(Bool::random_value(rng)) },
            "Float" => |rng| { BaseLiteral::Float(Float::random_value(rng)) },
            "Integer" => |rng| { BaseLiteral::Integer(Integer::random_value(rng)) },
            "Name" => |rng| { BaseLiteral::Name(Name::random_value(rng)) },
            _ => panic!("unknown literal type")
        }
    }
}

impl InstructionConfiguration for BaseLiteral {
    fn get_all_instructions() -> Vec<String> {
        vec!["BOOL.AND".to_owned(), "BOOL.DEFINE".to_owned()]
    }
}

impl SupportsLiteralNames<BaseLiteral> for BaseLiteral {
    fn supports_literal_names() -> bool {
        true
    }

    fn make_literal_name(name: Name) -> BaseLiteral {
        BaseLiteral::Name(name)
    }
}

pub struct BaseLiteralParser {}
impl Parser<BaseLiteral> for BaseLiteralParser {
    fn parse_code_instruction(input: &str) -> IResult<&str, Code<BaseLiteral>> {
        use nom::{branch::alt, bytes::complete::tag};
        let (input, instruction) = alt((tag("BOOL.AND"), tag("BOOL.DEFINE")))(input)?;
        let (input, _) = crate::parse::space_or_end(input)?;

        Ok((input, Code::Instruction(instruction.to_owned())))
    }
}

#[derive(Debug, PartialEq)]
pub struct BaseContext {
    exec_stack: Stack<Exec<BaseLiteral>>,

    bool_stack: Stack<Bool>,
    code_stack: Stack<Code<BaseLiteral>>,
    float_stack: Stack<Float>,
    integer_stack: Stack<Integer>,

    name_stack: Stack<Name>,
    quote_next_name: bool,
    defined_names: FnvHashMap<Name, Code<BaseLiteral>>,

    //config: Configuration<BaseLiteral>,
    instructions: Rc<InstructionTable<BaseContext>>,
}

impl BaseContext {
    pub fn new(_config: Configuration<BaseLiteral>) -> BaseContext {
        let mut instructions = InstructionTable::new();
        crate::execute_bool::BoolAnd::add_to_table(&mut instructions);
        crate::execute_bool::BoolDefine::<BaseContext, BaseLiteral>::add_to_table(&mut instructions);

        BaseContext {
            exec_stack: Stack::new(),
            bool_stack: Stack::new(),
            code_stack: Stack::new(),
            float_stack: Stack::new(),
            integer_stack: Stack::new(),
            name_stack: Stack::new(),
            quote_next_name: false,
            defined_names: FnvHashMap::default(),
            //config,
            instructions: Rc::new(instructions),
        }
    }
}

impl SupportsDefinedNames<BaseLiteral> for BaseContext {
    fn clear_defined_names(&mut self) {
        self.defined_names.clear();
    }

    fn define_name(&mut self, name: Name, code: Code<BaseLiteral>) {
        self.defined_names.insert(name, code);
    }

    fn definition_for(&self, name: &Name) -> Option<Code<BaseLiteral>>{
        match self.defined_names.get(name) {
            None => None,
            Some(code) => Some(code.clone()),
        }
    }
}

impl Context for BaseContext {
    fn clear(&mut self) {
        self.bool_stack.clear();
        self.code_stack.clear();
        self.exec_stack.clear();
        self.float_stack.clear();
        self.integer_stack.clear();
        self.name_stack.clear();
        self.quote_next_name = false;
        self.defined_names.clear();
    }

    fn next(&mut self) -> Option<usize> {
        // Pop the top piece of code from the exec stack and execute it.
        if let Some(exec) = self.exec_stack.pop() {
            match exec.into() {
                Code::List(mut list) => {
                    // Push the code in reverse order so the first item of the list is the top of stack
                    while let Some(item) = list.pop() {
                        self.exec_stack.push(item.into());
                    }
                }
                Code::Literal(literal) => match literal {
                    BaseLiteral::Bool(v) => self.bool_stack.push(v),
                    BaseLiteral::Float(v) => self.float_stack.push(v),
                    BaseLiteral::Integer(v) => self.integer_stack.push(v),
                    BaseLiteral::Name(v) => {
                        if self.quote_next_name {
                            self.name_stack.push(v);
                            self.quote_next_name = false;
                        } else {
                            match self.defined_names.get(&v) {
                                None => self.name_stack.push(v),
                                Some(code) => self.exec_stack.push(code.clone().into()),
                            }
                        }
                    }
                },
                Code::Instruction(name) => {
                    let instructions = self.instructions.clone();
                    instructions.execute(&name, self)
                },
            }

            // Return the number of points required to perform that action
            return Some(1);
        }

        // No action was found
        None
    }
}

impl ContextStack<Exec<BaseLiteral>> for BaseContext {
    fn len(&self) -> usize {
        self.exec_stack.len()
    }

    fn pop(&mut self) -> Option<Exec<BaseLiteral>> {
        self.exec_stack.pop()
    }

    fn push(&mut self, value: Exec<BaseLiteral>) {
        self.exec_stack.push(value)
    }

    fn get_stack(&mut self) -> &mut Stack<Exec<BaseLiteral>> {
        &mut self.exec_stack
    }
}

impl ContextStack<Bool> for BaseContext {
    fn len(&self) -> usize {
        self.bool_stack.len()
    }

    fn pop(&mut self) -> Option<Bool> {
        self.bool_stack.pop()
    }

    fn push(&mut self, value: Bool) {
        self.bool_stack.push(value)
    }

    fn get_stack(&mut self) -> &mut Stack<Bool> {
        &mut self.bool_stack
    }
}

impl ContextStack<Code<BaseLiteral>> for BaseContext {
    fn len(&self) -> usize {
        self.code_stack.len()
    }

    fn pop(&mut self) -> Option<Code<BaseLiteral>> {
        self.code_stack.pop()
    }

    fn push(&mut self, value: Code<BaseLiteral>) {
        self.code_stack.push(value)
    }

    fn get_stack(&mut self) -> &mut Stack<Code<BaseLiteral>> {
        &mut self.code_stack
    }
}

impl ContextStack<Float> for BaseContext {
    fn len(&self) -> usize {
        self.float_stack.len()
    }

    fn pop(&mut self) -> Option<Float> {
        self.float_stack.pop()
    }

    fn push(&mut self, value: Float) {
        self.float_stack.push(value)
    }

    fn get_stack(&mut self) -> &mut Stack<Float> {
        &mut self.float_stack
    }
}

impl ContextStack<Integer> for BaseContext {
    fn len(&self) -> usize {
        self.integer_stack.len()
    }

    fn pop(&mut self) -> Option<Integer> {
        self.integer_stack.pop()
    }

    fn push(&mut self, value: Integer) {
        self.integer_stack.push(value)
    }

    fn get_stack(&mut self) -> &mut Stack<Integer> {
        &mut self.integer_stack
    }
}

impl ContextStack<Name> for BaseContext {
    fn len(&self) -> usize {
        self.name_stack.len()
    }

    fn pop(&mut self) -> Option<Name> {
        self.name_stack.pop()
    }

    fn push(&mut self, value: Name) {
        self.name_stack.push(value)
    }

    fn get_stack(&mut self) -> &mut Stack<Name> {
        &mut self.name_stack
    }
}
