use crate::instruction_table::InstructionTable;
use crate::*;
use nom::IResult;
use std::fmt::{Display, Formatter, Result};
use std::rc::Rc;

// This file contains all the bits that will need to be code generated by macros in order for this to work. For the
// default version, we simply hand-code everything and then work on the macros to make this happen.

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum BaseLiteral {
    Bool(Bool),
    Float(Float),
    Integer(Integer),
    Name(Name),
}

impl Display for BaseLiteral {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        match &self {
            BaseLiteral::Bool(v) => v.nom_fmt(f),
            BaseLiteral::Float(v) => v.nom_fmt(f),
            BaseLiteral::Integer(v) => v.nom_fmt(f),
            BaseLiteral::Name(v) => v.nom_fmt(f),
        }
    }
}

impl LiteralEnum<BaseLiteral> for BaseLiteral {
    fn parse(input: &str) -> IResult<&str, BaseLiteral> {
        if let Ok((rest, value)) = Bool::parse(input) {
            return Ok((rest, BaseLiteral::Bool(value)));
        }
        if let Ok((rest, value)) = crate::parse::parse_code_float(input) {
            return Ok((rest, BaseLiteral::Float(value)));
        }
        if let Ok((rest, value)) = crate::parse::parse_code_integer(input) {
            return Ok((rest, BaseLiteral::Integer(value)));
        }
        if let Ok((rest, value)) = crate::parse::parse_code_name(input) {
            return Ok((rest, BaseLiteral::Name(value)));
        }

        Err(nom::Err::Error(nom::error::Error::new(input, nom::error::ErrorKind::Complete)))
    }
}

impl LiteralEnumHasLiteralValue<BaseLiteral, Bool> for BaseLiteral {
    fn supports_literal_type() -> bool {
        true
    }

    fn make_from_value(value: Bool) -> BaseLiteral {
        BaseLiteral::Bool(value)
    }
}

impl LiteralEnumHasLiteralValue<BaseLiteral, Float> for BaseLiteral {
    fn supports_literal_type() -> bool {
        true
    }

    fn make_from_value(value: Float) -> BaseLiteral {
        BaseLiteral::Float(value)
    }
}

impl LiteralEnumHasLiteralValue<BaseLiteral, Integer> for BaseLiteral {
    fn supports_literal_type() -> bool {
        true
    }

    fn make_from_value(value: Integer) -> BaseLiteral {
        BaseLiteral::Integer(value)
    }
}

impl LiteralEnumHasLiteralValue<BaseLiteral, Name> for BaseLiteral {
    fn supports_literal_type() -> bool {
        true
    }

    fn make_from_value(value: Name) -> BaseLiteral {
        BaseLiteral::Name(value)
    }
}

impl EphemeralConfiguration<BaseLiteral> for BaseLiteral {
    fn get_all_literal_types() -> Vec<String> {
        vec!["Bool".to_owned(), "Float".to_owned(), "Integer".to_owned(), "Name".to_owned()]
    }

    fn make_literal_constructor_for_type(literal_type: &str) -> LiteralConstructor<BaseLiteral> {
        match literal_type {
            "Bool" => |rng| BaseLiteral::Bool(Bool::random_value(rng)),
            "Float" => |rng| BaseLiteral::Float(Float::random_value(rng)),
            "Integer" => |rng| BaseLiteral::Integer(Integer::random_value(rng)),
            "Name" => |rng| BaseLiteral::Name(Name::random_value(rng)),
            _ => panic!("unknown literal type"),
        }
    }
}

impl InstructionConfiguration for BaseLiteral {
    fn get_all_instructions() -> Vec<String> {
        vec![
            crate::execute_bool::BoolAnd::<BaseContext, BaseLiteral>::name().to_owned(),
            crate::execute_bool::BoolDefine::<BaseContext, BaseLiteral>::name().to_owned(),
            crate::execute_bool::BoolDup::<BaseContext, BaseLiteral>::name().to_owned(),
        ]
    }
}

pub struct BaseLiteralParser {}
impl Parser<BaseLiteral> for BaseLiteralParser {
    fn parse_code_instruction(input: &str) -> IResult<&str, Code<BaseLiteral>> {
        use nom::{branch::alt, bytes::complete::tag};
        let (input, instruction) = alt((
            tag(crate::execute_bool::BoolAnd::<BaseContext, BaseLiteral>::name()),
            tag(crate::execute_bool::BoolDefine::<BaseContext, BaseLiteral>::name()),
            tag(crate::execute_bool::BoolDup::<BaseContext, BaseLiteral>::name())
        ))(input)?;
        let (input, _) = crate::parse::space_or_end(input)?;

        Ok((input, Code::Instruction(instruction.to_owned())))
    }
}

#[derive(Debug, PartialEq)]
pub struct BaseContext {
    exec_stack: Stack<Exec<BaseLiteral>>,

    bool_stack: Stack<Bool>,
    code_stack: Stack<Code<BaseLiteral>>,
    float_stack: Stack<Float>,
    integer_stack: Stack<Integer>,

    name_stack: NameStack<BaseLiteral>,

    //config: Configuration<BaseLiteral>,
    instructions: Rc<InstructionTable<BaseContext>>,
}

impl BaseContext {
    pub fn new(_config: Configuration<BaseLiteral>) -> BaseContext {
        let mut instructions = InstructionTable::new();
        crate::execute_bool::BoolAnd::<BaseContext, BaseLiteral>::add_to_table(&mut instructions);
        crate::execute_bool::BoolDefine::<BaseContext, BaseLiteral>::add_to_table(&mut instructions);
        crate::execute_bool::BoolDup::<BaseContext, BaseLiteral>::add_to_table(&mut instructions);

        BaseContext {
            exec_stack: Stack::new(),
            bool_stack: Stack::new(),
            code_stack: Stack::new(),
            float_stack: Stack::new(),
            integer_stack: Stack::new(),
            name_stack: NameStack::new(),
            //config,
            instructions: Rc::new(instructions),
        }
    }
}

impl Context for BaseContext {
    fn clear(&mut self) {
        self.bool_stack.clear();
        self.code_stack.clear();
        self.exec_stack.clear();
        self.float_stack.clear();
        self.integer_stack.clear();
        self.name_stack.clear();
    }

    fn next(&mut self) -> Option<usize> {
        // Pop the top piece of code from the exec stack and execute it.
        if let Some(exec) = self.exec_stack.pop() {
            match exec.into() {
                Code::List(mut list) => {
                    // Push the code in reverse order so the first item of the list is the top of stack
                    while let Some(item) = list.pop() {
                        self.exec_stack.push(item.into());
                    }
                }
                Code::Literal(literal) => match literal {
                    BaseLiteral::Bool(v) => self.bool_stack.push(v),
                    BaseLiteral::Float(v) => self.float_stack.push(v),
                    BaseLiteral::Integer(v) => self.integer_stack.push(v),
                    BaseLiteral::Name(v) => {
                        if self.name_stack.should_quote_next_name() {
                            self.name_stack.push(v);
                            self.name_stack.set_should_quote_next_name(false);
                        } else {
                            match self.name_stack.definition_for_name(&v) {
                                None => self.name_stack.push(v),
                                Some(code) => self.exec_stack.push(code.into()),
                            }
                        }
                    }
                },
                Code::Instruction(name) => {
                    let instructions = self.instructions.clone();
                    instructions.execute(&name, self)
                }
            }

            // Return the number of points required to perform that action
            return Some(1);
        }

        // No action was found
        None
    }
}

impl ContextHasExecStack<BaseLiteral> for BaseContext {
    fn exec(&self) -> &Stack<Exec<BaseLiteral>> {
        &self.exec_stack
    }
}

impl ContextHasBoolStack<BaseLiteral> for BaseContext {
    fn bool(&self) -> &Stack<Bool> {
        &self.bool_stack
    }

    fn make_literal_bool(value: Bool) -> Code<BaseLiteral> {
        Code::Literal(BaseLiteral::Bool(value))
    }
}

impl ContextHasCodeStack<BaseLiteral> for BaseContext {
    fn code(&self) -> &Stack<Code<BaseLiteral>> {
        &self.code_stack
    }
}

impl ContextHasFloatStack<BaseLiteral> for BaseContext {
    fn float(&self) -> &Stack<Float> {
        &self.float_stack
    }
    fn make_literal_float(value: Float) -> Code<BaseLiteral> {
        Code::Literal(BaseLiteral::Float(value))
    }
}

impl ContextHasIntegerStack<BaseLiteral> for BaseContext {
    fn integer(&self) -> &Stack<Integer> {
        &self.integer_stack
    }
    fn make_literal_integer(value: Integer) -> Code<BaseLiteral> {
        Code::Literal(BaseLiteral::Integer(value))
    }
}

impl ContextHasNameStack<BaseLiteral> for BaseContext {
    fn name(&self) -> &NameStack<BaseLiteral> {
        &self.name_stack
    }
    fn make_literal_name(value: Name) -> Code<BaseLiteral> {
        Code::Literal(BaseLiteral::Name(value))
    }
}
