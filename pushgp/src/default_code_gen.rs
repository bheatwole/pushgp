use crate::instruction_table::InstructionTable;
use crate::*;
use nom::IResult;
use pushgp_macros::*;
use std::fmt::{Display, Formatter, Result};
use std::rc::Rc;

// This file contains all the bits that will need to be code generated by macros in order for this to work. For the
// default version, we simply hand-code everything and then work on the macros to make this happen.

#[derive(Clone, Debug, Eq, Hash, PartialEq)]
pub enum BaseLiteral {
    Bool(Bool),
    Float(Float),
    Integer(Integer),
    Name(Name),
}

impl Display for BaseLiteral {
    fn fmt(&self, f: &mut Formatter<'_>) -> Result {
        match &self {
            BaseLiteral::Bool(v) => v.nom_fmt(f),
            BaseLiteral::Float(v) => v.nom_fmt(f),
            BaseLiteral::Integer(v) => v.nom_fmt(f),
            BaseLiteral::Name(v) => v.nom_fmt(f),
        }
    }
}

impl LiteralEnum<BaseLiteral> for BaseLiteral {
    fn parse(input: &str) -> IResult<&str, BaseLiteral> {
        if let Ok((rest, value)) = Bool::parse(input) {
            return Ok((rest, BaseLiteral::Bool(value)));
        }
        if let Ok((rest, value)) = crate::parse::parse_code_float(input) {
            return Ok((rest, BaseLiteral::Float(value)));
        }
        if let Ok((rest, value)) = crate::parse::parse_code_integer(input) {
            return Ok((rest, BaseLiteral::Integer(value)));
        }
        if let Ok((rest, value)) = crate::parse::parse_code_name(input) {
            return Ok((rest, BaseLiteral::Name(value)));
        }

        Err(nom::Err::Error(nom::error::Error::new(input, nom::error::ErrorKind::Complete)))
    }
}

impl LiteralEnumHasLiteralValue<BaseLiteral, Bool> for BaseLiteral {
    fn supports_literal_type() -> bool {
        true
    }

    fn make_from_value(value: Bool) -> BaseLiteral {
        BaseLiteral::Bool(value)
    }
}

impl LiteralEnumHasLiteralValue<BaseLiteral, Float> for BaseLiteral {
    fn supports_literal_type() -> bool {
        true
    }

    fn make_from_value(value: Float) -> BaseLiteral {
        BaseLiteral::Float(value)
    }
}

impl LiteralEnumHasLiteralValue<BaseLiteral, Integer> for BaseLiteral {
    fn supports_literal_type() -> bool {
        true
    }

    fn make_from_value(value: Integer) -> BaseLiteral {
        BaseLiteral::Integer(value)
    }
}

impl LiteralEnumHasLiteralValue<BaseLiteral, Name> for BaseLiteral {
    fn supports_literal_type() -> bool {
        true
    }

    fn make_from_value(value: Name) -> BaseLiteral {
        BaseLiteral::Name(value)
    }
}

impl EphemeralConfiguration<BaseLiteral> for BaseLiteral {
    fn get_all_literal_types() -> Vec<String> {
        vec!["Bool".to_owned(), "Float".to_owned(), "Integer".to_owned(), "Name".to_owned()]
    }

    fn make_literal_constructor_for_type(literal_type: &str) -> LiteralConstructor<BaseLiteral> {
        match literal_type {
            "Bool" => |rng| BaseLiteral::Bool(Bool::random_value(rng)),
            "Float" => |rng| BaseLiteral::Float(Float::random_value(rng)),
            "Integer" => |rng| BaseLiteral::Integer(Integer::random_value(rng)),
            "Name" => |rng| BaseLiteral::Name(Name::random_value(rng)),
            _ => panic!("unknown literal type"),
        }
    }
}

instruction_list! {
    context_name: BaseContext,
    literal_name: BaseLiteral,
    stacks: [
        Bool,
        Code,
        Exec,
        Float,
        Integer,
        Name,
    ],
    instructions: [
        crate::execute_bool::BoolAnd,
        crate::execute_bool::BoolDefine,
        crate::execute_bool::BoolDup,
        crate::execute_bool::BoolEqual,
        crate::execute_bool::BoolFlush,
        crate::execute_bool::BoolFromFloat,
        crate::execute_bool::BoolFromInt,
        crate::execute_bool::BoolNot,
        crate::execute_bool::BoolOr,
        crate::execute_bool::BoolPop,
        crate::execute_bool::BoolRand,
        crate::execute_bool::BoolRot,
        crate::execute_bool::BoolShove,
        crate::execute_bool::BoolStackDepth,
        crate::execute_bool::BoolSwap,
        crate::execute_bool::BoolYankDup,
        crate::execute_bool::BoolYank,
        crate::execute_code::CodeAppend,
        crate::execute_code::CodeAtom,
        crate::execute_code::CodeCar,
        crate::execute_code::CodeCdr,
        crate::execute_code::CodeCons,
        crate::execute_code::CodeContainer,
        crate::execute_code::CodeContains,
        crate::execute_code::CodeDefine,
        crate::execute_code::CodeDefinition,
        crate::execute_code::CodeDiscrepancy,
        crate::execute_code::CodeDoNCount,
        crate::execute_code::CodeDoNRange,
        crate::execute_code::CodeDoNTimes,
        crate::execute_code::CodeDoN,
        crate::execute_code::CodeDo,
        crate::execute_code::CodeDup,
        crate::execute_code::CodeEqual,
        crate::execute_code::CodeExtract,
        crate::execute_code::CodeFlush,
        crate::execute_code::CodeFromBoolean,
        crate::execute_code::CodeFromFloat,
        crate::execute_code::CodeFromInteger,
        crate::execute_code::CodeFromName,
        crate::execute_code::CodeIf,
        crate::execute_code::CodeInsert,
        crate::execute_code::CodeInstructions,
        crate::execute_code::CodeLength,
        crate::execute_code::CodeList,
        crate::execute_code::CodeMember,
        crate::execute_code::CodeNoop,
        crate::execute_code::CodeNthCdr,
        crate::execute_code::CodeNth,
        crate::execute_code::CodeNull,
        crate::execute_code::CodePop,
        crate::execute_code::CodePosition,
        crate::execute_code::CodeQuote,
        crate::execute_code::CodeRand,
        crate::execute_code::CodeRot,
        crate::execute_code::CodeShove,
        crate::execute_code::CodeSize,
        crate::execute_code::CodeStackDepth,
        crate::execute_code::CodeSubstitute,
        crate::execute_code::CodeSwap,
        crate::execute_code::CodeYankDup,
        crate::execute_code::CodeYank,
        crate::execute_exec::ExecDefine,
        crate::execute_exec::ExecDoNCount,
        crate::execute_exec::ExecDoNRange,
        crate::execute_exec::ExecDoNTimes,
        crate::execute_exec::ExecDup,
        crate::execute_exec::ExecEqual,
        crate::execute_exec::ExecFlush,
        crate::execute_exec::ExecIf,
        crate::execute_exec::ExecK,
        crate::execute_exec::ExecPop,
        crate::execute_exec::ExecRot,
        crate::execute_exec::ExecShove,
        crate::execute_exec::ExecStackDepth,
        crate::execute_exec::ExecSwap,
        crate::execute_exec::ExecS,
        crate::execute_exec::ExecYankDup,
        crate::execute_exec::ExecYank,
        crate::execute_exec::ExecY,

        crate::execute_integer::IntegerDup,
        crate::execute_integer::IntegerEqual,
        crate::execute_integer::IntegerPop,
        crate::execute_integer::IntegerSum,
    ],
}
// impl InstructionConfiguration for BaseLiteral {
//     fn get_all_instructions() -> Vec<String> {
//         vec![
//             crate::execute_bool::BoolAnd::<BaseContext, BaseLiteral>::name().to_owned(),
//             crate::execute_bool::BoolDefine::<BaseContext, BaseLiteral>::name().to_owned(),
//             crate::execute_bool::BoolDup::<BaseContext, BaseLiteral>::name().to_owned(),
//         ]
//     }
// // }

// pub struct BaseLiteralParser {}
// impl Parser<BaseLiteral> for BaseLiteralParser {
//     fn parse_code_instruction(input: &str) -> IResult<&str, Code<BaseLiteral>> {
//         use nom::{branch::alt, bytes::complete::tag};
//         let (input, instruction) = alt((
//             tag(crate::execute_bool::BoolAnd::<BaseContext, BaseLiteral>::name()),
//             tag(crate::execute_bool::BoolDefine::<BaseContext, BaseLiteral>::name()),
//             tag(crate::execute_bool::BoolDup::<BaseContext, BaseLiteral>::name()),
//         ))(input)?;
//         let (input, _) = crate::parse::space_or_end(input)?;

//         Ok((input, Code::Instruction(instruction.to_owned())))
//     }
// }

/// Creates a new instruction table that contains every instruction known in the base library. This will fail to compile
// /// if your Context does not include stacks for all base library types.
// pub fn new_instruction_table_with_all_instructions<C, L>() -> InstructionTable<C>
// where
//     C: Context + ContextHasBoolStack<L> + ContextHasNameStack<L>,
//     L: LiteralEnum<L>,
// {
//     let mut instructions = InstructionTable::new();
//     crate::execute_bool::BoolAnd::<C, L>::add_to_table(&mut instructions);
//     crate::execute_bool::BoolDefine::<C, L>::add_to_table(&mut instructions);
//     crate::execute_bool::BoolDup::<C, L>::add_to_table(&mut instructions);

//     instructions
// }

#[derive(Debug, PartialEq)]
pub struct BaseContext {
    exec_stack: Stack<Exec<BaseLiteral>>,

    bool_stack: Stack<Bool>,
    code_stack: Stack<Code<BaseLiteral>>,
    float_stack: Stack<Float>,
    integer_stack: Stack<Integer>,

    name_stack: NameStack<BaseLiteral>,

    //config: Configuration<BaseLiteral>,
    instructions: Rc<InstructionTable<BaseContext>>,
}

impl BaseContext {
    pub fn new(_config: Configuration<BaseLiteral>, instructions: InstructionTable<BaseContext>) -> BaseContext {
        BaseContext {
            exec_stack: Stack::new(),
            bool_stack: Stack::new(),
            code_stack: Stack::new(),
            float_stack: Stack::new(),
            integer_stack: Stack::new(),
            name_stack: NameStack::new(),
            //config,
            instructions: Rc::new(instructions),
        }
    }
}

impl Context for BaseContext {
    fn clear(&mut self) {
        self.bool_stack.clear();
        self.code_stack.clear();
        self.exec_stack.clear();
        self.float_stack.clear();
        self.integer_stack.clear();
        self.name_stack.clear();
    }

    fn all_instruction_names(&self) -> Vec<String> {
        self.instructions.all_instruction_names()
    }

    fn next(&mut self) -> Option<usize> {
        // Pop the top piece of code from the exec stack and execute it.
        if let Some(exec) = self.exec_stack.pop() {
            match exec.into() {
                Code::List(mut list) => {
                    // Push the code in reverse order so the first item of the list is the top of stack
                    while let Some(item) = list.pop() {
                        self.exec_stack.push(item.into());
                    }
                }
                Code::Literal(literal) => match literal {
                    BaseLiteral::Bool(v) => self.bool_stack.push(v),
                    BaseLiteral::Float(v) => self.float_stack.push(v),
                    BaseLiteral::Integer(v) => self.integer_stack.push(v),
                    BaseLiteral::Name(v) => {
                        if self.name_stack.should_quote_next_name() {
                            self.name_stack.push(v);
                            self.name_stack.set_should_quote_next_name(false);
                        } else {
                            match self.name_stack.definition_for_name(&v) {
                                None => self.name_stack.push(v),
                                Some(code) => self.exec_stack.push(code.into()),
                            }
                        }
                    }
                },
                Code::Instruction(name) => {
                    let instructions = self.instructions.clone();
                    instructions.execute(&name, self)
                }
            }

            // Return the number of points required to perform that action
            return Some(1);
        }

        // No action was found
        None
    }
}

impl ContextHasExecStack<BaseLiteral> for BaseContext {
    fn exec(&self) -> &Stack<Exec<BaseLiteral>> {
        &self.exec_stack
    }
}

impl ContextHasBoolStack<BaseLiteral> for BaseContext {
    fn bool(&self) -> &Stack<Bool> {
        &self.bool_stack
    }

    fn make_literal_bool(value: Bool) -> Code<BaseLiteral> {
        Code::Literal(BaseLiteral::Bool(value))
    }
}

impl ContextHasCodeStack<BaseLiteral> for BaseContext {
    fn code(&self) -> &Stack<Code<BaseLiteral>> {
        &self.code_stack
    }
}

impl ContextHasFloatStack<BaseLiteral> for BaseContext {
    fn float(&self) -> &Stack<Float> {
        &self.float_stack
    }
    fn make_literal_float(value: Float) -> Code<BaseLiteral> {
        Code::Literal(BaseLiteral::Float(value))
    }
}

impl ContextHasIntegerStack<BaseLiteral> for BaseContext {
    fn integer(&self) -> &Stack<Integer> {
        &self.integer_stack
    }
    fn make_literal_integer(value: Integer) -> Code<BaseLiteral> {
        Code::Literal(BaseLiteral::Integer(value))
    }
}

impl ContextHasNameStack<BaseLiteral> for BaseContext {
    fn name(&self) -> &NameStack<BaseLiteral> {
        &self.name_stack
    }
    fn make_literal_name(value: Name) -> Code<BaseLiteral> {
        Code::Literal(BaseLiteral::Name(value))
    }
}

#[cfg(test)]
mod tests {
    use crate::*;

    #[test]
    fn base_literal_has_get_all_instructions() {
        let all_instructions = BaseLiteral::get_all_instructions();
        assert!(all_instructions.contains(&"BOOL.AND".to_owned()));
        assert!(all_instructions.contains(&"BOOL.DEFINE".to_owned()));
        assert!(all_instructions.contains(&"BOOL.DUP".to_owned()));
    }
}
